# 框架的测试目标

框架包含三大部分：
 * 负载模拟
 * 请求调度
 * 数据收集

## 框架的基本原理

本框架采用JMeter的设计思路，算是一个简易版本的JMeter：

建立一个线程池，多线程运行取样器产生大量负载，在运行过程中，记录每次请求的时长，通过监听器来记录测试结果，并展示到前台。

当前需求比较简单，就是记录每个请求的时长。

涉及到3个主要的模块：

* 负载模拟
* 请求调度
* 数据收集

### 负载模拟设计思路

  * 测试用例中有参数化的需求，可以通过"配置元件"或者"前置处理器"来完成
  * 有关联需求，可通过"后置处理器"来完成
  * 想要设置运行场景，如模拟多少用户，运行多长时间，可以设置"线程组"
  * 想要模拟并发场景，可以利用"定时器"来设置
  * 想要控制业务的执行逻辑，如登录操作只运行一次，可以使用控制器来完成

#### 相关概念

* 测试用例

  在JMeter中，就是“取样器”。但是并不好理解，在我们自己的框架中，直接叫做“测试用例”，直接对应QA的一个Test Case，直观明了。

  举个例子：一个测试用例就是测试一个API，也就是一个Http Request。

  一个“测试用例”，封装成一个Java的线程对象，并赋予一个名称，这个很重要。

* 测试用例组

  多个“测试用例”组成，这些“测试用例”组成一个测试场景。多个测试用例之间可能存在一定的相互依赖关系。

* 配置元件

  就是每个“测试用例”包含的各个部分。具体包含如下内容： 

  * 请求使用的协议。例如：HTTP, HTTPS, TCP等等
  * 请求发送目的地的URL。这个可以拆分成2部分：
    * Domain_Name  ( Host_Name/IP + Port_Number)，如：shopex.homecredit.cn
    
    * Request Path，如：/suning/phone/iPhone/11
    
      Domain_Name 与 Request Path组合成一个完整的请求URL，或者EndPoint。
  * 请求类型，如：GET，POST，PUT，DELETE等等。如果是TCP，没有这个选项。
  * 请求参数（GET：URL上的参数；POST/Update：Body），设置一段JSON。如果是GET，框架会自动转成K-V的形式，放到URL上；如果是POST等请求类型，会完成的把JSON放到Body里传过去。

* 前置处理器

  “前置处理器”也是JMeter中的概念，当JMeter的“取样器”发起请求前，可以用这做一些工作，比如参数化等等。我们沿用JMeter的这个概念，可用于“线程组”中各个线程之间传递数据使用。

* 后置处理器

  “后置处理器”也是JMeter中的概念，当JMeter的“取样器”收到响应后做一些工作，比如提取响应报文中的内容。我们沿用JMeter的这个概念，可用于“线程组”中各个线程之间传递数据使用。

* 定时器

* 控制器

#### 负载模拟的主要参数

 * 设置总（Java）线程数
 * 设置线程数增长率。暂时采用线性增长的算法，易于实现。
 * 设置初始线程数(<=总线程数，需要校验)
 * 设置每个线程的业务数据 -- TODO: 应该从“参数”里删除。这个属于代码层级

### 请求调度

请求调度的含义，简单的说，就是模拟用户量增长的过程。

### 数据收集



## 几种测试的含义

 * 性能测试：
   <p>
   模拟用户负载来测试系统在负载情况下，系统的响应时间，吞吐量等。
   （这里的负载指的是用户并发数）所以它的目的是为了获取系统的指标。
   </p>
 * 负载测试：
   <p>
   在一定的软硬件环境上，通过不断的加大负载来确定在满足性能指标情况下
   所能够承受的最大用户数。所以它的目的是为了获取最大用户数。
   一般不超过80%cpu，正常情况工作下最大用户数数据。
   </p>

 * 压力测试
   <p>
   也叫强度测试。
   在一定的软件硬件环境下，通过高负载的手段来使服务器资源处于极限的状态，
   测试该系统在极限状态长时间运行是否稳定。包括系统指标，服务器性能指标。
   </p>
